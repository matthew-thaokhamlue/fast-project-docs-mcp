"""
Document structure models for PRD, SPEC, and DESIGN documents.

These models define the specific structure and content organization
for each type of document generated by the system.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional


@dataclass
class PRDStructure:
    """Structure for Product Requirements Document."""
    
    introduction: str = ""
    objectives: List[str] = field(default_factory=list)
    user_stories: List[Dict[str, Any]] = field(default_factory=list)
    acceptance_criteria: List[str] = field(default_factory=list)
    success_metrics: List[str] = field(default_factory=list)
    constraints: List[str] = field(default_factory=list)
    assumptions: List[str] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    
    def add_user_story(self, role: str, feature: str, benefit: str, 
                      criteria: List[str] = None) -> None:
        """Add a user story with acceptance criteria."""
        story = {
            "story": f"As a {role}, I want {feature}, so that {benefit}",
            "role": role,
            "feature": feature,
            "benefit": benefit,
            "criteria": criteria or []
        }
        self.user_stories.append(story)
    
    def add_acceptance_criteria(self, criteria: str) -> None:
        """Add acceptance criteria in EARS format."""
        # Ensure EARS format: WHEN [event] THEN [system] SHALL [response]
        if not any(keyword in criteria.upper() for keyword in ["WHEN", "IF", "WHERE"]):
            criteria = f"WHEN applicable THEN the system SHALL {criteria}"
        self.acceptance_criteria.append(criteria)
    
    def validate_completeness(self) -> List[str]:
        """Validate PRD completeness and return missing elements."""
        issues = []
        
        if not self.introduction.strip():
            issues.append("Missing introduction section")
        
        if not self.objectives:
            issues.append("No objectives defined")
        
        if not self.user_stories:
            issues.append("No user stories defined")
        
        if not self.acceptance_criteria:
            issues.append("No acceptance criteria defined")
        
        # Check user story format
        for i, story in enumerate(self.user_stories):
            if not all(key in story for key in ["role", "feature", "benefit"]):
                issues.append(f"User story {i+1} missing required elements")
        
        return issues

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "introduction": self.introduction,
            "objectives": self.objectives,
            "user_stories": self.user_stories,
            "acceptance_criteria": self.acceptance_criteria,
            "success_metrics": self.success_metrics,
            "constraints": self.constraints,
            "assumptions": self.assumptions,
            "dependencies": self.dependencies
        }


@dataclass
class SPECStructure:
    """Structure for Technical Specification Document."""
    
    overview: str = ""
    architecture: str = ""
    components: List[Dict[str, Any]] = field(default_factory=list)
    interfaces: List[Dict[str, Any]] = field(default_factory=list)
    data_models: List[Dict[str, Any]] = field(default_factory=list)
    implementation_details: List[str] = field(default_factory=list)
    testing_strategy: str = ""
    deployment_considerations: List[str] = field(default_factory=list)
    
    def add_component(self, name: str, description: str, 
                     responsibilities: List[str] = None,
                     dependencies: List[str] = None) -> None:
        """Add a system component."""
        component = {
            "name": name,
            "description": description,
            "responsibilities": responsibilities or [],
            "dependencies": dependencies or [],
            "interfaces": []
        }
        self.components.append(component)
    
    def add_interface(self, name: str, interface_type: str, 
                     description: str, methods: List[Dict[str, Any]] = None) -> None:
        """Add an interface specification."""
        interface = {
            "name": name,
            "type": interface_type,  # 'REST', 'GraphQL', 'gRPC', 'Internal'
            "description": description,
            "methods": methods or [],
            "authentication": "",
            "rate_limits": ""
        }
        self.interfaces.append(interface)
    
    def add_data_model(self, name: str, description: str,
                      fields: List[Dict[str, Any]] = None,
                      relationships: List[str] = None) -> None:
        """Add a data model specification."""
        model = {
            "name": name,
            "description": description,
            "fields": fields or [],
            "relationships": relationships or [],
            "validation_rules": [],
            "indexes": []
        }
        self.data_models.append(model)
    
    def validate_completeness(self) -> List[str]:
        """Validate SPEC completeness and return missing elements."""
        issues = []
        
        if not self.overview.strip():
            issues.append("Missing technical overview")
        
        if not self.architecture.strip():
            issues.append("Missing architecture description")
        
        if not self.components:
            issues.append("No components defined")
        
        if not self.testing_strategy.strip():
            issues.append("Missing testing strategy")
        
        # Validate component structure
        for i, component in enumerate(self.components):
            if not component.get("name") or not component.get("description"):
                issues.append(f"Component {i+1} missing name or description")
        
        return issues

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "overview": self.overview,
            "architecture": self.architecture,
            "components": self.components,
            "interfaces": self.interfaces,
            "data_models": self.data_models,
            "implementation_details": self.implementation_details,
            "testing_strategy": self.testing_strategy,
            "deployment_considerations": self.deployment_considerations
        }


@dataclass
class DESIGNStructure:
    """Structure for Design Document."""

    system_design: str = ""
    user_interface_design: str = ""
    data_flow: str = ""
    implementation_approach: str = ""
    design_patterns: List[Dict[str, Any]] = field(default_factory=list)
    ui_components: List[Dict[str, Any]] = field(default_factory=list)
    workflows: List[Dict[str, Any]] = field(default_factory=list)
    constraints: List[str] = field(default_factory=list)
    security_considerations: List[str] = field(default_factory=list)
    performance_requirements: List[str] = field(default_factory=list)
    
    def add_design_pattern(self, pattern_name: str, description: str,
                          use_case: str, implementation_notes: str = "") -> None:
        """Add a design pattern specification."""
        pattern = {
            "name": pattern_name,
            "description": description,
            "use_case": use_case,
            "implementation_notes": implementation_notes,
            "benefits": [],
            "trade_offs": []
        }
        self.design_patterns.append(pattern)
    
    def add_security_consideration(self, consideration: str) -> None:
        """Add a security consideration."""
        self.security_considerations.append(consideration)
    
    def add_performance_requirement(self, requirement: str) -> None:
        """Add a performance requirement."""
        self.performance_requirements.append(requirement)
    
    def validate_completeness(self) -> List[str]:
        """Validate DESIGN completeness and return missing elements."""
        issues = []
        
        if not self.system_design.strip():
            issues.append("Missing system design description")
        
        if not self.data_flow.strip():
            issues.append("Missing data flow description")
        
        if not self.implementation_approach.strip():
            issues.append("Missing implementation approach")
        
        if not self.security_considerations:
            issues.append("No security considerations defined")
        
        if not self.performance_requirements:
            issues.append("No performance requirements defined")
        
        return issues

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "system_design": self.system_design,
            "user_interface_design": self.user_interface_design,
            "data_flow": self.data_flow,
            "implementation_approach": self.implementation_approach,
            "design_patterns": self.design_patterns,
            "ui_components": self.ui_components,
            "workflows": self.workflows,
            "constraints": self.constraints,
            "security_considerations": self.security_considerations,
            "performance_requirements": self.performance_requirements
        }


@dataclass
class DocumentMetadata:
    """Metadata for generated documents."""
    
    document_type: str  # 'prd', 'spec', 'design'
    version: str = "1.0"
    author: str = "MCP Document Generator"
    created_date: str = ""
    last_modified: str = ""
    related_documents: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    review_status: str = "draft"  # 'draft', 'review', 'approved'
    
    def to_frontmatter(self) -> str:
        """Convert metadata to YAML frontmatter."""
        frontmatter = [
            "---",
            f"document_type: {self.document_type}",
            f"version: {self.version}",
            f"author: {self.author}",
            f"created_date: {self.created_date}",
            f"last_modified: {self.last_modified}",
            f"review_status: {self.review_status}",
        ]
        
        if self.related_documents:
            frontmatter.append("related_documents:")
            for doc in self.related_documents:
                frontmatter.append(f"  - {doc}")
        
        if self.tags:
            frontmatter.append("tags:")
            for tag in self.tags:
                frontmatter.append(f"  - {tag}")
        
        frontmatter.append("---")
        return "\n".join(frontmatter)
